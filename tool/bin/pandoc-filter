#!/usr/bin/env node

const fs = require('fs')
const net = require('net')
const child_process = require('child_process')
const yargs = require('yargs')
const getStream = require('get-stream')
const winston = require('winston')

const { sockPath, logger }= require('../lib/common.js')
const pandocFilterInit = require('../lib/pandoc-filter.js')

var argv = yargs
  .strict()
  .options({
    server: {
      type: 'boolean',
      default: false,
      describe: 'run as server'
    }
  })
  .argv

const nospawn = process.env['PD_FILTER_NO_SPAWN']

async function runAsClient () {

  const client = net.createConnection({ path: sockPath, allowHalfOpen: true }, () => {
    process.stdin.pipe(client)
    client.pipe(process.stdout)
  })
  
  client.on('error', async (e) => {
    if (e.code !== 'ECONNREFUSED' && e.code !== 'ENOENT') {
      throw e
    }

    // ECONNREFUSED/ENOENT 表示没有服务端, 除非 nospawn 否则启动一个 server
    if (!nospawn) {
      child_process.spawn('pandoc-filter', ['--server'], {
        stdio: 'ignore',
        detached: true
      }).unref()
    }

    // 这一次的自己处理
    const pandocFilter = await pandocFilterInit()
    process.stdout.end(await pandocFilter(await getStream(process.stdin)))
  })

}

async function runAsServer () {

  const pandocFilter = await pandocFilterInit()
  const server = net.createServer({ allowHalfOpen: true }, async (c) => {
    try {
      let input = await getStream(c)
      if (!input.length) {
        c.end()
        return
      }
      logger().log({ level: 'info', comp: 'pandoc-filter', message: `input length ${input.length}` })
      let output = await pandocFilter(input)
      logger().log({ level: 'info', comp: 'pandoc-filter', message: `output length ${output.length}` })
      c.end(output)
    } catch (e) {
      logger().log({ level: 'error', comp: 'pandoc-filter', error: String(e) })
    } finally {
      c.end()
    }
  })

  server.on('error', (e) => {
    // EADDRINUSE 有两种情况, 或者是真的有, 或者是退出了但还没有清理 sock,
    // 我们连接一下试试就知道了
    // https://stackoverflow.com/a/16502680/157235
    if (e.code !== 'EADDRINUSE') {
      throw e
    }
    let c = new net.Socket()
    c.on('error', (err) => {
      if (err.code === 'ECONNREFUSED') {
        fs.unlinkSync(sockPath)
        server.listen(sockPath)
      }
    })
    c.connect(sockPath, () => {
      process.exit()
    })
  })
  server.listen(sockPath)

}

async function main () {
  await (argv.server ? runAsServer() : runAsClient())
}

main().then(() => {})
