#!/usr/bin/env node

const fs = require('fs')
const net = require('net')
const child_process = require('child_process')
const yargs = require('yargs')
const getStream = require('get-stream')
const winston = require('winston')
const pandocFilterInit = require('../lib/pandoc-filter.js')

const sockPath = '/tmp/pandoc-filter.sock'

var argv = yargs
  .strict()
  .options({
    server: {
      type: 'boolean',
      default: false,
      describe: 'run as server'
    }
  })
  .argv

async function runAsClient () {

  const client = net.createConnection({ path: sockPath, allowHalfOpen: true }, () => {
    process.stdin.pipe(client)
    client.pipe(process.stdout)
  })
  
  client.on('error', async (e) => {
    if (e.code !== 'ECONNREFUSED' && e.code !== 'ENOENT') {
      throw e
    }
    // ECONNREFUSED 表示没有服务端, 所以启动一个 server, 但这一次的就自己处理好了
    child_process.spawn('pandoc-filter', ['--server'], {
      stdio: 'ignore',
      detached: true
    }).unref()

    const pandocFilter = await pandocFilterInit()
    process.stdout.end(await pandocFilter(await getStream(process.stdin)))

  })

}

async function runAsServer () {

  const { combine, timestamp, json } = winston.format

  const logger = winston.createLogger({
    level: 'info',
    format: combine(timestamp(), json()),
    transports: [
      new winston.transports.File({ filename: '/tmp/pandoc-filter.log', level: 'info' })
    ]
  })

  const pandocFilter = await pandocFilterInit()
  const server = net.createServer({ allowHalfOpen: true }, async (c) => {
    try {
      let input = await getStream(c)
      if (!input.length) {
        c.end()
        return
      }
      logger.log({ level: 'info', message: `input length ${input.length}` })
      let output = await pandocFilter(input)
      logger.log({ level: 'info', message: `output length ${output.length}` })
      c.end(output)
    } catch (e) {
      logger.log({
        level: 'error',
        message: e
      })
    } finally {
      c.end()
    }
  })

  server.on('error', (e) => {
    // EADDRINUSE 有两种情况, 或者是真的有, 或者是退出了但还没有清理 sock,
    // 我们连接一下试试就知道了
    // https://stackoverflow.com/a/16502680/157235
    if (e.code !== 'EADDRINUSE') {
      throw e
    }
    let c = new net.Socket()
    c.on('error', (err) => {
      if (err.code === 'ECONNREFUSED') {
        fs.unlinkSync(sockPath)
        server.listen(sockPath)
      }
    })
    c.connect(sockPath, () => {
      process.exit()
    })
  })
  server.listen(sockPath)

}

async function main () {
  await (argv.server ? runAsServer() : runAsClient())
}

main().then(() => {})
