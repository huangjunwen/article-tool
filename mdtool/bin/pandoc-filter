#!/usr/bin/env node

const fs = require('fs')
const assert = require('assert').ok
const getStream = require('get-stream')
const prism = require('prismjs')
const { init: tex2svgInit } = require('../lib/tex2svg.js')

/////////////////////// 环境变量 ///////////////////////

// 如果 MATHJAX_CLIENT_RENDER=1 的话则在客户端渲染, 否则在服务端渲染
const mjxClientRender = process.env['MATHJAX_CLIENT_RENDER'] === '1'

// 指定客户端 cdn js url
const mjxClientJSUrl = process.env['MATHJAX_CLIENT_JS_URL'] || 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js'

// mathjax 的 font cache 设置, server side render 只支持 none/local, client side render 则支持 none/local/global
const mjxFontCache = process.env['MATHJAX_FONT_CACHE'] || (mjxClientRender ? 'global' : 'none')
assert(mjxFontCache === 'none' || mjxFontCache === 'local' || (mjxFontCache === 'global' && mjxClientRender))

// 代码高亮 css 主题路径
const prismThemePath = process.env['PRISM_THEME_PATH'] || require.resolve('prismjs/themes/prism-tomorrow.css')

/////////////////////////////////////////////////////////

// 参考自
//   https://graemephi.github.io/posts/static-katex-with-hugo/
//   https://gist.github.com/graemephi/7c60093f342b6dabf00d976492b6c91f
async function renderMath (data) {

  if (mjxClientRender) {
    data.blocks.push({
      t: 'RawBlock',
      c: ['html', `<script>
  window.MathJax = {
    options: {
      processHtmlClass: 'math'
    },
    svg: {
      fontCache: '${mjxFontCache}'
    }
  }; 
  (function () {
    var script = document.createElement('script');
    script.src = '${mjxClientJSUrl}';
    script.async = true;
    document.head.appendChild(script);
  })();
</script>`]
    })
    return
  }

  const { tex2svg, css } = await tex2svgInit({
    fontCache: mjxFontCache !== 'none'
  })

  function visitMath (block) {
    if (block.t === 'Math') {
      const [{ t: mathType }, value] = block.c
      const inline = mathType == 'InlineMath'
      block.t = 'RawInline'
      block.c = ['html', tex2svg(value, { inline, container: true })]
      return
    }
    if (Array.isArray(block.c)) {
      block.c.forEach(visitMath)
      return
    }
  }
  data.blocks.forEach(visitMath)

  data.blocks.push({
    t: 'RawBlock',
    c: ['html', css]
  })

}

async function renderCode(data) {

  function visitCode (block) {
    if (block.t === 'CodeBlock') {
      const [[_id, classes, _attrs], value] = block.c
      let lang = classes.length > 0 ? classes[0] : ''
      let langAttr = lang ? ` class="language-${lang}"` : ''
      let grammer = prism.languages[lang]
      let code = grammer ? prism.highlight(value, grammer, lang) : prism.util.encode(value)
      block.c = ['html', `<pre><code${langAttr}>${code}</code></pre>`]
      block.t = 'RawBlock'
      return
    }
    if (Array.isArray(block.c)) {
      block.c.forEach(visitCode)
      return
    }
  }
  data.blocks.forEach(visitCode)

  const css = fs.readFileSync(prismThemePath)
  data.blocks.push({
    t: 'RawBlock',
    c: ['html', `<style>${css}</style>`]
  })
}

async function main () {
  let data = JSON.parse(await getStream(process.stdin))
  await renderMath(data)
  await renderCode(data)
  console.log(JSON.stringify(data))
}

main().then(() => {})
